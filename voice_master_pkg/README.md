# マスター　(happy_voice ver)

もとあるモジュールを取り入れて一連のロボットの動きとして行う方法を記述する．  

---

## [talk_master](voice_master_pkg/talk_master.py)

### モジュールを使用する際の前提条件
この**マスター**は人間が発生した言葉をそのまま返す生産性のないマスターである．  
使用しているモジュール  
- **stt_whisper** 音声を取得して文字列を出す（文字起こし）モジュール
- **tts_piper**  入力した言葉を発する（合成音声）モジュール

**stt_whisper**では音声を取得して文字を出すが，プログラムとして**リクエスト**するものはない．  
そのため流れとしては  
  
マスターが空の情報を送る  **リクエスト**  
↓  
サーバーが受け取って処理を開始（音声取得と文字起こしをする）  
↓  
文字起こししたものをもとのマスターへ返す  **レスポンス**  
  
となっている.   
  
  
  
**tts_piper**では文字を取得して音声を出す．これは発生したい文字を**リクエスト**する必要がある  
ただし，音声を発する処理はサーバーが全部するため返すものはない．
そのため流れとしては   
  
マスターが言わせたい言葉（text）を送る　**リクエスト**  
↓  
サーバーが文字を受け取って言葉を発する  
↓  
マスター側は特に受け取るものはない  
  
初っ端から特殊であるが２つのモジュールは逆であると考えるといい．  

--- 

### 実際のコード

最初に使うサーバーの**メッセージの型**をインポートすること  
今回は**２つのモジュール**を使っておりそれぞれ使う**メッセージの型**をクラスとしてインポートしている．  

```py
from happy_interfaces.srv import Whisper, Piper
```

説明すると**from**のあとにかくことは**ディレクトリの場所**である．今回はhappy_interfacesの中のsrvにメッセージの型がある  
pythonのインポートはディレクトリのパスを指定する際には`/`ではなく`.`で表す．  
```bash
happy_interfaces/srv/Whisper.srv
happy_interfaces/srv/Piper.srv
#この場所に２つのメッセージの型が存在している．そのため
happpy_interfaces.srv
```
importのあとは当然使うsrvファイルを指定している. 拡張子はつけないこと  

これでメッセージの型はインポートできた．  

次にnodeのclassを作成する．  
今回はマスター（クライアント）として作るがサーバー側の書き方とほぼ同じ．  
初期化のメゾット`__init__`には使うモジュールをクライアント関数を用いて指定する．  

```py
self.tts_srv = self.create_client(Piper, '/piper')
#ウィスパー（音声聞き入れ）のサーバー指定
self.stt_srv = self.create_client(Whisper, '/whisper_service')
```

必要な引数は最初にメッセージの型，次にサーバーの名前である．  
つまりモジュール自体を持ってきているのではなく，モジュールによって建てられた**サーバー**を指定している．  
関数で作ったものを`self.~`で代入している．これは後に使う．  

これで通信おを行う準備は整った．  

次に，新たなメゾットを使う．ここにリクエストを送るコードを記載する．
まずは`speak_request`これは言葉を発するため，引数には発したい言葉を格納する `text`をおいた．  
```py
request = Piper.Request()
```
インポートしたメッセージの型のリクエストのクラスをインスタンス化してる．  
横文字ばかりだが，リクエストを送るための変数を作っている．今回は`request`という名前にしており．送りたい文字（text）を後に代入する．  

```py
request.text = text
```

インスタンス化したrequestには`.text`があるがこれはメッセージの型（Piper.srv）に含まれている.リクエストの変数名だからである．
```
#Piper.srvの中身
string text   #これはstring型のtextという名前の変数　リクエスト
---
bool success  #これはbool型のsuccessという名前の変数　レスポンス
```
このメッセージの型を使うサービス通信（モジュール）は**文字列のtext**を送ると**TrueかFalse**が帰ってくる．  
今回はsuccessは使わない…理由はサーバー側で処理した音声がほしいだけで値はいらないため．  

あとはこれをサーバーへ送る  
```py
#ここでサーバーにリクエストしている．　（非同期処理）
self.fur = self.tts_srv.call_async(request)
```
`self.tts_srv`は`__init__`で作ったものである．  
これに.call_async(request)を入れるとサーバーへ送られる．  
このときこれは**非同期の処理**として行われる．  
ここでそれは何だと    
| 非同期 | 同期的 |
| --- | --- |
| call_async() | call_async() と　rclpy.spin_until_future_complete() |
| 処理がすぐにメインにもどる | 終わるまでメインの処理は動かない |

つまり非同期にすると音声を発している間，も別の処理を動かすことができる．  
同期的だと音声を発している間は他の処理はできなくなる．  
同期的が使いにくいように思えるがこれがいい利点になるときもある　　→　　`whisper_srv`とか  

話を戻すが，メゾットを実際に使用する際は `def main()` に記述する．
```py
def main(args=None):
    rclpy.init(args=args)
    simple_client = SimpleClient()     #  クライアンとオブジェクトの生成  （pythonのインスタンス化とほぼ同じ）

    simple_client.speak_request('私馬鹿です')       # リクエストを送る
```

これでメゾット内で言う`text`に「私馬鹿です」が代入されこれをリクエストとして送る．  
これにより「私馬鹿です」と言葉を発することができる．  

もう一つ`whisper_srv`というメゾットがある．
これは文字起こしをするモジュールを使うため，リクエストするものはない．  
```py
#ウィスパーはリクエストないのでからである．ただしインスタンス化はする．
re = Whisper.Request()
```
前と同じようにメッセージの型をインスタンス化している．  
しかし、今回はリクエストするものはないためからの状態でサーバーへ送る  
```py
get_str = self.stt_srv.call_async(re)
#サーバーの処理が終わるまで待つ（ブロック）　（これがあったら同期的な処理となる）
rclpy.spin_until_future_complete(self, get_str)
```
これは同期的な処理となってる  
理由：  
音声を取り込むという処理は時間がかかる…このときにメインの処理を動かすと文字起こしした値を取得できないまま担ってしまい．望んだ結果を得られないから．  

これは`Whisper.srv`の中身である．  
```
---
bool success　　　　#レスポンス
string sentences
```
`---`で区切っている前に何も書いていないためリクエストはない．  
区切ったあとはレスポンスがありどうやら２つの値が帰ってくる．  
我々は文字起こしした文字列がほしいためstring型の`sentences`をげっちゅする．
```py
#返り値がレスポンス
return get_str.result()
```
ここでレスポンスをメゾットの戻り値（返り値）として書く．  
実際に使うときは`main()`

```py
def main(args=None):
    rclpy.init(args=args)
    simple_client = SimpleClient()     #  クライアンとオブジェクトの生成  （pythonのインスタンス化とほぼ同じ）
    #指定したメゾットを呼び出してる．これはウィスパー　このとき文字をreに代入してる
    re = simple_client.whisper_srv().sentences
    print(f'文字起こしした内容は：{re}')
```
simple_client.whisper_srv()はget_str.result()を返す．  
これに`.sentences`を入れるとレスポンスの一つであるsentencesの値をげっチュできる  
これにより,print文で文字起こしした内容を出力してる
